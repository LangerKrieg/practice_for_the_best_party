_______________________________________________________________________________________________________________________________________________________
function dfsBridges(v):
  time = time + 1
  used[v] = true
  enter[v] = time
  ret[v] = time 
  for всех u смежных с v
    if (v, u) — обратное ребро
      ret[v] = min(ret[v], enter[u])
    if !used[u]
      dfsBridges(u)
      ret[v] = min(ret[v], ret[u]) 
      if ret[u] > enter[v] 
        ребро (v, u) — мост
	addBridge(v, u, bridges)

function findBridges():
  time = 0
  for для всех вершин
    used[i] = false
  for для всех вершин
    if !used[i]
      dfsBridges(i)
_______________________________________________________________________________________________________________________________________________________

function dfsComps(v):
  used[v] = true
  comp.push_back(v)
  for всех u смежных с v
    if !used[u]
      dfsComps(u);

fuction findComps():
  for для всех вершин
    used[i] = false
  for для всех вершин
    if !used[i]
      clear(comp)
      dfsComps(i)
_______________________________________________________________________________________________________________________________________________________

function deleteBridges():
  findBridges()
  for каждого моста с вершинами v, u из bridges
    deleteEdge(v, u)
_______________________________________________________________________________________________________________________________________________________
enter[v] - время захода поиска в глубину в определённую вершину v
ret[v] - минимум из: времени захода в саму вершину enter[v], времён захода в каждую вершину p, являющуюся концом некоторого обратного ребра (v,p), а также из всех значений ret[to] для каждой вершины to, являющейся непосредственным сыном v
comp - список вершин в текущей компоненте связности
bridges - список, содержащий мосты
_____________________________________________________________________________________________________________________________________________________
